const { default: makeWASocket, useMultiFileAuthState, fetchLatestBaileysVersion } = require('@whiskeysockets/baileys');
const qrcode = require('qrcode');
const axios = require('axios');
const FormData = require('form-data');
const fs = require('fs');
require('dotenv').config();

const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID;
const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
const QR_SENT_FLAG = './qr_sent.flag';

(async () => {
  const { state, saveCreds } = await useMultiFileAuthState('auth');
  const { version } = await fetchLatestBaileysVersion();

  const sock = makeWASocket({
    version,
    auth: state,
    printQRInTerminal: false,
    syncFullHistory: false
  });

  // ØªÙˆÙ„ÙŠØ¯ Ø±Ù…Ø² QR ÙˆØ¥Ø±Ø³Ø§Ù„Ù‡ Ø¥Ù„Ù‰ ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·
  sock.ev.on('connection.update', async update => {
    const { qr, connection } = update;

    if (qr && !fs.existsSync(QR_SENT_FLAG)) {
      const qrImagePath = './qr.png';
      await qrcode.toFile(qrImagePath, qr);

      const form = new FormData();
      form.append('chat_id', TELEGRAM_CHAT_ID);
      form.append('photo', fs.createReadStream(qrImagePath));
      form.append('caption', 'ğŸ”‘ Ø±Ù…Ø² QR Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¥Ù„Ù‰ ÙˆØ§ØªØ³Ø§Ø¨');

      await axios.post(
        `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`,
        form,
        { headers: form.getHeaders() }
      );

      fs.writeFileSync(QR_SENT_FLAG, 'sent');
      console.log('âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ù…Ø² QR Ø¥Ù„Ù‰ ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…');
    }

    if (connection === 'open') {
      console.log('ğŸ¤– Ø§Ù„Ø¨ÙˆØª Ø¬Ø§Ù‡Ø² ÙˆÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø¨Ø§Ø´Ø±Ø©.');
    }
  });

  // Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙˆØ§Ù„Ø±Ø¯ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… OpenRouter
  sock.ev.on('messages.upsert', async ({ messages, type }) => {
    if (type !== 'notify') return;

    const msg = messages[0];
    if (!msg.message || msg.key.fromMe) return;

    const sender = msg.key.remoteJid;
    const text = msg.message.conversation || msg.message.extendedTextMessage?.text;

    if (!text) return;

    console.log(`ğŸ“© Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø±Ø¯Ø© Ù…Ù† ${sender}: ${text}`);

    try {
      const response = await axios.post(
        'https://openrouter.ai/api/v1/chat/completions',
        {
          model: 'mistral/mistral-7b-instruct',
          messages: [{ role: 'user', content: text }],
          max_tokens: 1000
        },
        {
          headers: {
            'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
            'Content-Type': 'application/json'
          }
        }
      );

      const reply = response.data?.choices?.[0]?.message?.content || 'Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† ØªÙˆÙ„ÙŠØ¯ Ø±Ø¯.';
      await sock.sendMessage(sender, { text: reply });
      console.log(`âœ… ØªÙ… Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ ${sender}`);
    } catch (error) {
      console.error('âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ù„Ø©:', error.message);
      await sock.sendMessage(sender, { text: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±Ø³Ø§Ù„ØªÙƒ.' });
    }
  });

  // Ø­ÙØ¸ Ø§Ù„Ø¬Ù„Ø³Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
  sock.ev.on('creds.update', saveCreds);
})();
